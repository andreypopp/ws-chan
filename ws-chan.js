// Generated by CoffeeScript 1.6.2
(function() {
  var Channel, EventEmitter, Stream, SyncTransform, backoff, websocket,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  websocket = require('websocket-stream');

  backoff = require('backoff');

  Stream = require('stream');

  EventEmitter = require('events').EventEmitter;

  SyncTransform = (function(_super) {
    __extends(SyncTransform, _super);

    function SyncTransform(fn, options) {
      if (options == null) {
        options = {};
      }
      options = Object.create(options);
      options.objectMode = true;
      SyncTransform.__super__.constructor.call(this, options);
      this.fn = fn;
    }

    SyncTransform.prototype._transform = function(chunk, encoding, cb) {
      var e;

      try {
        return cb(null, this.fn != null ? this.fn(chunk) : chunk);
      } catch (_error) {
        e = _error;
        return cb(e, null);
      }
    };

    return SyncTransform;

  })(Stream.Transform);

  Channel = (function(_super) {
    __extends(Channel, _super);

    function Channel(uri, options) {
      if (options == null) {
        options = {};
      }
      this.uri = uri;
      this.options = options;
      this.sock = void 0;
      this.preventBackoff = false;
      this.backoffState = options.backoff || backoff.exponential(options);
      if (this.backoffState != null) {
        if (options.failAfter != null) {
          this.backoffState.failAfter(options.failAfter);
        }
        this.backoffState.on('backoff', this.onBackoff.bind(this));
        this.backoffState.on('ready', this.onBackoffReady.bind(this));
        this.backoffState.on('fail', this.onBackoffFail.bind(this));
      }
      this["in"] = new Stream.PassThrough({
        objectMode: true
      });
      this.out = new Stream.PassThrough({
        objectMode: true
      });
      this.out.pause();
      if (options.start) {
        this.start();
      }
    }

    Channel.prototype.start = function() {
      if (this.sock != null) {
        return;
      }
      this.sock = this.createSocket();
      this.sock.on('open', this.onOpen.bind(this));
      this.sock.on('end', this.onEnd.bind(this));
      this.sock.on('error', this.onError.bind(this));
      this.sock.pipe(new SyncTransform(JSON.parse)).pipe(this["in"], {
        end: false
      });
      return this.out.pipe(new SyncTransform(JSON.stringify), {
        end: false
      }).pipe(this.sock);
    };

    Channel.prototype.stop = function() {
      this.preventBackoff = true;
      return this.sock.end();
    };

    Channel.prototype.backoff = function() {
      if ((this.backoffState != null) && !this.preventBackoff) {
        return this.backoffState.backoff();
      }
    };

    Channel.prototype.resetBackoff = function() {
      if (this.backoffState != null) {
        return this.backoffState.reset();
      }
    };

    Channel.prototype.createSocket = function() {
      return websocket(this.uri);
    };

    Channel.prototype.cleanup = function() {
      this.out.unpipe();
      return this.sock = void 0;
    };

    Channel.prototype.log = function(msg) {
      return console.log("channel: " + msg);
    };

    Channel.prototype.onOpen = function() {
      this.out.resume();
      this.log("connection established");
      this.emit('open', this);
      return this.resetBackoff();
    };

    Channel.prototype.onEnd = function() {
      this.out.pause();
      this.log("connection terminated");
      this.emit('end', this);
      this.cleanup();
      return this.backoff();
    };

    Channel.prototype.onError = function(e) {
      this.out.pause();
      this.log("error " + e);
      this.emit('error', e, this);
      this.cleanup();
      return this.backoff();
    };

    Channel.prototype.onBackoff = function(number, delay) {
      return this.log("next connection attempt in " + delay + "ms");
    };

    Channel.prototype.onBackoffReady = function() {
      this.log("trying to re-establish connection");
      return this.start();
    };

    Channel.prototype.onBackoffFail = function() {
      return this.log("out of attempts to re-establish connection");
    };

    return Channel;

  })(EventEmitter);

  module.exports = function(uri, options) {
    return new Channel(uri, options);
  };

  module.exports.channel = exports;

  module.exports.Channel = Channel;

}).call(this);
