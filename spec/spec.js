// Generated by CoffeeScript 1.6.2
(function() {
  var Channel, TestChannel, deepEqual, equal, stream, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  stream = require('stream');

  _ref = require('assert'), equal = _ref.equal, deepEqual = _ref.deepEqual;

  Channel = require('../ws-chan').Channel;

  TestChannel = (function(_super) {
    __extends(TestChannel, _super);

    function TestChannel(options) {
      if (options == null) {
        options = {};
      }
      TestChannel.__super__.constructor.call(this, '', options);
    }

    TestChannel.prototype.createSocket = function() {
      var open, sock;

      sock = new stream.PassThrough;
      open = function() {
        return sock.emit('open');
      };
      setTimeout(open, 50);
      return sock;
    };

    return TestChannel;

  })(Channel);

  describe('Channel', function() {
    it('writes to sock on write to Channel.out', function(done) {
      var chan;

      chan = new TestChannel({
        start: true
      });
      chan.sock.on('data', function(chunk) {
        var data;

        data = JSON.parse(chunk);
        deepEqual(data, {
          hello: 'world'
        });
        return done();
      });
      return chan.out.write({
        hello: 'world'
      });
    });
    it('allows messages from sock can be read from Channel.in', function(done) {
      var chan;

      chan = new TestChannel({
        start: true
      });
      chan["in"].on('data', function(message) {
        deepEqual(message, {
          hello: 'world'
        });
        return done();
      });
      return chan.sock.write(JSON.stringify({
        hello: 'world'
      }));
    });
    it('allows messages from sock can be read from Channel.in (delayed start)', function(done) {
      var chan;

      chan = new TestChannel();
      chan["in"].on('data', function(message) {
        deepEqual(message, {
          hello: 'world'
        });
        return done();
      });
      chan.start();
      return chan.sock.write(JSON.stringify({
        hello: 'world'
      }));
    });
    it('queues outgoing messages before connect', function(done) {
      var chan;

      chan = new TestChannel();
      chan.out.write({
        hello: 'world'
      });
      chan.on('open', function() {
        return chan.sock.on('data', function(chunk) {
          var data;

          data = JSON.parse(chunk);
          deepEqual(data, {
            hello: 'world'
          });
          return done();
        });
      });
      return chan.start();
    });
    return describe('reconnection logic', function() {
      return it('re-establishes connection on end of a socket stream', function(done) {
        var chan, first;

        first = true;
        chan = new TestChannel({
          start: true
        });
        chan["in"].on('data', function(message) {
          deepEqual(message, {
            hello: 'world'
          });
          return done();
        });
        return chan.on('open', function() {
          if (first) {
            chan.sock.end();
            return first = false;
          } else {
            return chan.sock.write(JSON.stringify({
              hello: 'world'
            }));
          }
        });
      });
    });
  });

}).call(this);
